/* automatically generated by rust-bindgen 0.66.1 */

#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::unreadable_literal)]
#![allow(clippy::upper_case_acronyms)]
#![allow(rustdoc::broken_intra_doc_links)]

pub const UB_STATS_QTYPE_NUM: u32 = 256;
pub const UB_STATS_QCLASS_NUM: u32 = 256;
pub const UB_STATS_RCODE_NUM: u32 = 16;
pub const UB_STATS_OPCODE_NUM: u32 = 16;
pub const UB_STATS_BUCKET_NUM: u32 = 40;
pub const UB_STATS_RPZ_ACTION_NUM: u32 = 10;
#[doc = " The validation context is created to hold the resolver status,\n validation keys and a small cache (containing messages, rrsets,\n roundtrip times, trusted keys, lameness information).\n\n Its contents are internally defined."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ub_ctx {
    _unused: [u8; 0],
}
#[doc = " The validation and resolution results.\n Allocated by the resolver, and need to be freed by the application\n with ub_resolve_free()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ub_result {
    #[doc = " The original question, name text string."]
    pub qname: *mut ::std::os::raw::c_char,
    #[doc = " the type asked for"]
    pub qtype: ::std::os::raw::c_int,
    #[doc = " the class asked for"]
    pub qclass: ::std::os::raw::c_int,
    #[doc = " a list of network order DNS rdata items, terminated with a\n NULL pointer, so that data[0] is the first result entry,\n data[1] the second, and the last entry is NULL.\n If there was no data, data[0] is NULL."]
    pub data: *mut *mut ::std::os::raw::c_char,
    #[doc = " the length in bytes of the data items, len[i] for data[i]"]
    pub len: *mut ::std::os::raw::c_int,
    #[doc = " canonical name for the result (the final cname).\n zero terminated string.\n May be NULL if no canonical name exists."]
    pub canonname: *mut ::std::os::raw::c_char,
    #[doc = " DNS RCODE for the result. May contain additional error code if\n there was no data due to an error. 0 (NOERROR) if okay."]
    pub rcode: ::std::os::raw::c_int,
    #[doc = " The DNS answer packet. Network formatted. Can contain DNSSEC types."]
    pub answer_packet: *mut ::std::os::raw::c_void,
    #[doc = " length of the answer packet in octets."]
    pub answer_len: ::std::os::raw::c_int,
    #[doc = " If there is any data, this is true.\n If false, there was no data (nxdomain may be true, rcode can be set)."]
    pub havedata: ::std::os::raw::c_int,
    #[doc = " If there was no data, and the domain did not exist, this is true.\n If it is false, and there was no data, then the domain name\n is purported to exist, but the requested data type is not available."]
    pub nxdomain: ::std::os::raw::c_int,
    #[doc = " True, if the result is validated securely.\n False, if validation failed or domain queried has no security info.\n\n It is possible to get a result with no data (havedata is false),\n and secure is true. This means that the non-existence of the data\n was cryptographically proven (with signatures)."]
    pub secure: ::std::os::raw::c_int,
    #[doc = " If the result was not secure (secure==0), and this result is due\n to a security failure, bogus is true.\n This means the data has been actively tampered with, signatures\n failed, expected signatures were not present, timestamps on\n signatures were out of date and so on.\n\n If !secure and !bogus, this can happen if the data is not secure\n because security is disabled for that domain name.\n This means the data is from a domain where data is not signed."]
    pub bogus: ::std::os::raw::c_int,
    #[doc = " If the result is bogus this contains a string (zero terminated)\n that describes the failure.  There may be other errors as well\n as the one described, the description may not be perfectly accurate.\n Is NULL if the result is not bogus."]
    pub why_bogus: *mut ::std::os::raw::c_char,
    #[doc = " If the query or one of its subqueries was ratelimited.  Useful if\n ratelimiting is enabled and answer to the client is SERVFAIL as a\n result."]
    pub was_ratelimited: ::std::os::raw::c_int,
    #[doc = " TTL for the result, in seconds.  If the security is bogus, then\n you also cannot trust this value."]
    pub ttl: ::std::os::raw::c_int,
}
#[doc = " Callback for results of async queries.\n The readable function definition looks like:\n void my_callback(void* my_arg, int err, struct ub_result* result);\n It is called with\n\tvoid* my_arg: your pointer to a (struct of) data of your choice,\n\t\tor NULL.\n\tint err: if 0 all is OK, otherwise an error occurred and no results\n\t     are forthcoming.\n\tstruct result: pointer to more detailed result structure.\n\t\tThis structure is allocated on the heap and needs to be\n\t\tfreed with ub_resolve_free(result);"]
pub type ub_callback_type = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ub_result,
    ),
>;
#[doc = " no error"]
pub const ub_ctx_err_UB_NOERROR: ub_ctx_err = 0;
#[doc = " socket operation. Set to -1, so that if an error from _fd() is\n passed (-1) it gives a socket error."]
pub const ub_ctx_err_UB_SOCKET: ub_ctx_err = -1;
#[doc = " alloc failure"]
pub const ub_ctx_err_UB_NOMEM: ub_ctx_err = -2;
#[doc = " syntax error"]
pub const ub_ctx_err_UB_SYNTAX: ub_ctx_err = -3;
#[doc = " DNS service failed"]
pub const ub_ctx_err_UB_SERVFAIL: ub_ctx_err = -4;
#[doc = " fork() failed"]
pub const ub_ctx_err_UB_FORKFAIL: ub_ctx_err = -5;
#[doc = " cfg change after finalize()"]
pub const ub_ctx_err_UB_AFTERFINAL: ub_ctx_err = -6;
#[doc = " initialization failed (bad settings)"]
pub const ub_ctx_err_UB_INITFAIL: ub_ctx_err = -7;
#[doc = " error in pipe communication with async bg worker"]
pub const ub_ctx_err_UB_PIPE: ub_ctx_err = -8;
#[doc = " error reading from file (resolv.conf)"]
pub const ub_ctx_err_UB_READFILE: ub_ctx_err = -9;
#[doc = " error async_id does not exist or result already been delivered"]
pub const ub_ctx_err_UB_NOID: ub_ctx_err = -10;
#[doc = " The error constants"]
pub type ub_ctx_err = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Create a resolving and validation context.\n The information from /etc/resolv.conf and /etc/hosts is not utilised by\n default. Use ub_ctx_resolvconf and ub_ctx_hosts to read them.\n @return a new context. default initialisation.\n \treturns NULL on error."]
    pub fn ub_ctx_create() -> *mut ub_ctx;
}
extern "C" {
    #[doc = " Destroy a validation context and free all its resources.\n Outstanding async queries are killed and callbacks are not called for them.\n @param ctx: context to delete."]
    pub fn ub_ctx_delete(ctx: *mut ub_ctx);
}
extern "C" {
    #[doc = " Set an option for the context.\n @param ctx: context.\n @param opt: option name from the unbound.conf config file format.\n\t(not all settings applicable). The name includes the trailing ':'\n\tfor example ub_ctx_set_option(ctx, \"logfile:\", \"mylog.txt\");\n \tThis is a power-users interface that lets you specify all sorts\n \tof options.\n \tFor some specific options, such as adding trust anchors, special\n \troutines exist.\n @param val: value of the option.\n @return: 0 if OK, else error."]
    pub fn ub_ctx_set_option(
        ctx: *mut ub_ctx,
        opt: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get an option from the context.\n @param ctx: context.\n @param opt: option name from the unbound.conf config file format.\n\t(not all settings applicable). The name excludes the trailing ':'\n\tfor example ub_ctx_get_option(ctx, \"logfile\", &result);\n \tThis is a power-users interface that lets you specify all sorts\n \tof options.\n @param str: the string is malloced and returned here. NULL on error.\n \tThe caller must free() the string.  In cases with multiple\n \tentries (auto-trust-anchor-file), a newline delimited list is\n \treturned in the string.\n @return 0 if OK else an error code (malloc failure, syntax error)."]
    pub fn ub_ctx_get_option(
        ctx: *mut ub_ctx,
        opt: *const ::std::os::raw::c_char,
        str_: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " setup configuration for the given context.\n @param ctx: context.\n @param fname: unbound config file (not all settings applicable).\n \tThis is a power-users interface that lets you specify all sorts\n \tof options.\n \tFor some specific options, such as adding trust anchors, special\n \troutines exist.\n @return: 0 if OK, else error."]
    pub fn ub_ctx_config(
        ctx: *mut ub_ctx,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set machine to forward DNS queries to, the caching resolver to use.\n IP4 or IP6 address. Forwards all DNS requests to that machine, which\n is expected to run a recursive resolver. If the proxy is not\n DNSSEC-capable, validation may fail. Can be called several times, in\n that case the addresses are used as backup servers.\n\n To read the list of nameservers from /etc/resolv.conf (from DHCP or so),\n use the call ub_ctx_resolvconf.\n\n @param ctx: context.\n\tAt this time it is only possible to set configuration before the\n\tfirst resolve is done.\n @param addr: address, IP4 or IP6 in string format.\n \tIf the addr is NULL, forwarding is disabled.\n @return 0 if OK, else error."]
    pub fn ub_ctx_set_fwd(
        ctx: *mut ub_ctx,
        addr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Use DNS over TLS to send queries to machines set with ub_ctx_set_fwd().\n\n @param ctx: context.\n\tAt this time it is only possible to set configuration before the\n\tfirst resolve is done.\n @param tls: enable or disable DNS over TLS\n @return 0 if OK, else error."]
    pub fn ub_ctx_set_tls(ctx: *mut ub_ctx, tls: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a stub zone, with given address to send to.  This is for custom\n root hints or pointing to a local authoritative dns server.\n For dns resolvers and the 'DHCP DNS' ip address, use ub_ctx_set_fwd.\n This is similar to a stub-zone entry in unbound.conf.\n\n @param ctx: context.\n\tIt is only possible to set configuration before the\n\tfirst resolve is done.\n @param zone: name of the zone, string.\n @param addr: address, IP4 or IP6 in string format.\n \tThe addr is added to the list of stub-addresses if the entry exists.\n \tIf the addr is NULL the stub entry is removed.\n @param isprime: set to true to set stub-prime to yes for the stub.\n \tFor local authoritative servers, people usually set it to false,\n \tFor root hints it should be set to true.\n @return 0 if OK, else error."]
    pub fn ub_ctx_set_stub(
        ctx: *mut ub_ctx,
        zone: *const ::std::os::raw::c_char,
        addr: *const ::std::os::raw::c_char,
        isprime: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read list of nameservers to use from the filename given.\n Usually \"/etc/resolv.conf\". Uses those nameservers as caching proxies.\n If they do not support DNSSEC, validation may fail.\n\n Only nameservers are picked up, the searchdomain, ndots and other\n settings from resolv.conf(5) are ignored.\n\n @param ctx: context.\n\tAt this time it is only possible to set configuration before the\n\tfirst resolve is done.\n @param fname: file name string. If NULL \"/etc/resolv.conf\" is used.\n @return 0 if OK, else error."]
    pub fn ub_ctx_resolvconf(
        ctx: *mut ub_ctx,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read list of hosts from the filename given.\n Usually \"/etc/hosts\".\n These addresses are not flagged as DNSSEC secure when queried for.\n\n @param ctx: context.\n\tAt this time it is only possible to set configuration before the\n\tfirst resolve is done.\n @param fname: file name string. If NULL \"/etc/hosts\" is used.\n @return 0 if OK, else error."]
    pub fn ub_ctx_hosts(
        ctx: *mut ub_ctx,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a trust anchor to the given context.\n The trust anchor is a string, on one line, that holds a valid DNSKEY or\n DS RR.\n @param ctx: context.\n\tAt this time it is only possible to add trusted keys before the\n\tfirst resolve is done.\n @param ta: string, with zone-format RR on one line.\n \t[domainname] [TTL optional] [type] [class optional] [rdata contents]\n @return 0 if OK, else error."]
    pub fn ub_ctx_add_ta(
        ctx: *mut ub_ctx,
        ta: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add trust anchors to the given context.\n Pass name of a file with DS and DNSKEY records (like from dig or drill).\n @param ctx: context.\n\tAt this time it is only possible to add trusted keys before the\n\tfirst resolve is done.\n @param fname: filename of file with keyfile with trust anchors.\n @return 0 if OK, else error."]
    pub fn ub_ctx_add_ta_file(
        ctx: *mut ub_ctx,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add trust anchor to the given context that is tracked with RFC5011\n automated trust anchor maintenance.  The file is written to when the\n trust anchor is changed.\n Pass the name of a file that was output from eg. unbound-anchor,\n or you can start it by providing a trusted DNSKEY or DS record on one\n line in the file.\n @param ctx: context.\n\tAt this time it is only possible to add trusted keys before the\n\tfirst resolve is done.\n @param fname: filename of file with trust anchor.\n @return 0 if OK, else error."]
    pub fn ub_ctx_add_ta_autr(
        ctx: *mut ub_ctx,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add trust anchors to the given context.\n Pass the name of a bind-style config file with trusted-keys{}.\n @param ctx: context.\n\tAt this time it is only possible to add trusted keys before the\n\tfirst resolve is done.\n @param fname: filename of file with bind-style config entries with trust\n \tanchors.\n @return 0 if OK, else error."]
    pub fn ub_ctx_trustedkeys(
        ctx: *mut ub_ctx,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set debug output (and error output) to the specified stream.\n Pass NULL to disable. Default is stderr.\n @param ctx: context.\n @param out: FILE* out file stream to log to.\n \tType void* to avoid stdio dependency of this header file.\n @return 0 if OK, else error."]
    pub fn ub_ctx_debugout(
        ctx: *mut ub_ctx,
        out: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set debug verbosity for the context\n Output is directed to stderr.\n @param ctx: context.\n @param d: debug level, 0 is off, 1 is very minimal, 2 is detailed,\n\tand 3 is lots.\n @return 0 if OK, else error."]
    pub fn ub_ctx_debuglevel(ctx: *mut ub_ctx, d: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a context behaviour for asynchronous action.\n @param ctx: context.\n @param dothread: if true, enables threading and a call to resolve_async()\n\tcreates a thread to handle work in the background.\n\tIf false, a process is forked to handle work in the background.\n\tChanges to this setting after async() calls have been made have\n\tno effect (delete and re-create the context to change).\n @return 0 if OK, else error."]
    pub fn ub_ctx_async(ctx: *mut ub_ctx, dothread: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Poll a context to see if it has any new results\n Do not poll in a loop, instead extract the fd below to poll for readiness,\n and then check, or wait using the wait routine.\n @param ctx: context.\n @return: 0 if nothing to read, or nonzero if a result is available.\n \tIf nonzero, call ctx_process() to do callbacks."]
    pub fn ub_poll(ctx: *mut ub_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for a context to finish with results. Calls ub_process() after\n the wait for you. After the wait, there are no more outstanding\n asynchronous queries.\n @param ctx: context.\n @return: 0 if OK, else error."]
    pub fn ub_wait(ctx: *mut ub_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get file descriptor. Wait for it to become readable, at this point\n answers are returned from the asynchronous validating resolver.\n Then call the ub_process to continue processing.\n This routine works immediately after context creation, the fd\n does not change.\n @param ctx: context.\n @return: -1 on error, or file descriptor to use select(2) with."]
    pub fn ub_fd(ctx: *mut ub_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call this routine to continue processing results from the validating\n resolver (when the fd becomes readable).\n Will perform necessary callbacks.\n @param ctx: context\n @return: 0 if OK, else error."]
    pub fn ub_process(ctx: *mut ub_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform resolution and validation of the target name.\n @param ctx: context.\n\tThe context is finalized, and can no longer accept config changes.\n @param name: domain name in text format (a zero terminated text string).\n @param rrtype: type of RR in host order, 1 is A (address).\n @param rrclass: class of RR in host order, 1 is IN (for internet).\n @param result: the result data is returned in a newly allocated result\n \tstructure. May be NULL on return, return value is set to an error\n \tin that case (out of memory).\n @return 0 if OK, else error."]
    pub fn ub_resolve(
        ctx: *mut ub_ctx,
        name: *const ::std::os::raw::c_char,
        rrtype: ::std::os::raw::c_int,
        rrclass: ::std::os::raw::c_int,
        result: *mut *mut ub_result,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform resolution and validation of the target name.\n Asynchronous, after a while, the callback will be called with your\n data and the result.\n @param ctx: context.\n\tIf no thread or process has been created yet to perform the\n\twork in the background, it is created now.\n\tThe context is finalized, and can no longer accept config changes.\n @param name: domain name in text format (a string).\n @param rrtype: type of RR in host order, 1 is A.\n @param rrclass: class of RR in host order, 1 is IN (for internet).\n @param mydata: this data is your own data (you can pass NULL),\n \tand is passed on to the callback function.\n @param callback: this is called on completion of the resolution.\n \tIt is called as:\n \tvoid callback(void* mydata, int err, struct ub_result* result)\n \twith mydata: the same as passed here, you may pass NULL,\n \twith err: is 0 when a result has been found.\n \twith result: a newly allocated result structure.\n\t\tThe result may be NULL, in that case err is set.\n\n \tIf an error happens during processing, your callback will be called\n \twith error set to a nonzero value (and result==NULL).\n @param async_id: if you pass a non-NULL value, an identifier number is\n\treturned for the query as it is in progress. It can be used to\n\tcancel the query.\n @return 0 if OK, else error."]
    pub fn ub_resolve_async(
        ctx: *mut ub_ctx,
        name: *const ::std::os::raw::c_char,
        rrtype: ::std::os::raw::c_int,
        rrclass: ::std::os::raw::c_int,
        mydata: *mut ::std::os::raw::c_void,
        callback: ub_callback_type,
        async_id: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cancel an async query in progress.\n Its callback will not be called.\n\n @param ctx: context.\n @param async_id: which query to cancel.\n @return 0 if OK, else error.\n This routine can return an error if the async_id passed does not exist\n or has already been delivered. If another thread is processing results\n at the same time, the result may be delivered at the same time and the\n cancel fails with an error.  Also the cancel can fail due to a system\n error, no memory or socket failures."]
    pub fn ub_cancel(ctx: *mut ub_ctx, async_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free storage associated with a result structure.\n @param result: to free"]
    pub fn ub_resolve_free(result: *mut ub_result);
}
extern "C" {
    #[doc = " Convert error value to a human readable string.\n @param err: error code from one of the libunbound functions.\n \tThe error codes are from the type enum ub_ctx_err.\n @return pointer to constant text string, zero terminated."]
    pub fn ub_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Debug routine.  Print the local zone information to debug output.\n @param ctx: context.  Is finalized by the routine.\n @return 0 if OK, else error."]
    pub fn ub_ctx_print_local_zones(ctx: *mut ub_ctx) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a new zone with the zonetype to the local authority info of the\n library.\n @param ctx: context.  Is finalized by the routine.\n @param zone_name: name of the zone in text, \"example.com\"\n\tIf it already exists, the type is updated.\n @param zone_type: type of the zone (like for unbound.conf) in text.\n @return 0 if OK, else error."]
    pub fn ub_ctx_zone_add(
        ctx: *mut ub_ctx,
        zone_name: *const ::std::os::raw::c_char,
        zone_type: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove zone from local authority info of the library.\n @param ctx: context.  Is finalized by the routine.\n @param zone_name: name of the zone in text, \"example.com\"\n\tIf it does not exist, nothing happens.\n @return 0 if OK, else error."]
    pub fn ub_ctx_zone_remove(
        ctx: *mut ub_ctx,
        zone_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add localdata to the library local authority info.\n Similar to local-data config statement.\n @param ctx: context.  Is finalized by the routine.\n @param data: the resource record in text format, for example\n\t\"www.example.com IN A 127.0.0.1\"\n @return 0 if OK, else error."]
    pub fn ub_ctx_data_add(
        ctx: *mut ub_ctx,
        data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove localdata from the library local authority info.\n @param ctx: context.  Is finalized by the routine.\n @param data: the name to delete all data from, like \"www.example.com\".\n @return 0 if OK, else error."]
    pub fn ub_ctx_data_remove(
        ctx: *mut ub_ctx,
        data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a version string from the libunbound implementation.\n @return a static constant string with the version number."]
    pub fn ub_version() -> *const ::std::os::raw::c_char;
}
#[doc = " Some global statistics that are not in struct stats_info,\n this struct is shared on a shm segment (shm-key in unbound.conf)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ub_shm_stat_info {
    pub num_threads: ::std::os::raw::c_int,
    pub time: ub_shm_stat_info__bindgen_ty_1,
    pub mem: ub_shm_stat_info__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ub_shm_stat_info__bindgen_ty_1 {
    pub now_sec: ::std::os::raw::c_longlong,
    pub now_usec: ::std::os::raw::c_longlong,
    pub up_sec: ::std::os::raw::c_longlong,
    pub up_usec: ::std::os::raw::c_longlong,
    pub elapsed_sec: ::std::os::raw::c_longlong,
    pub elapsed_usec: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ub_shm_stat_info__bindgen_ty_2 {
    pub msg: ::std::os::raw::c_longlong,
    pub rrset: ::std::os::raw::c_longlong,
    pub val: ::std::os::raw::c_longlong,
    pub iter: ::std::os::raw::c_longlong,
    pub subnet: ::std::os::raw::c_longlong,
    pub ipsecmod: ::std::os::raw::c_longlong,
    pub respip: ::std::os::raw::c_longlong,
    pub dnscrypt_shared_secret: ::std::os::raw::c_longlong,
    pub dnscrypt_nonce: ::std::os::raw::c_longlong,
    pub dynlib: ::std::os::raw::c_longlong,
}
#[doc = " per worker statistics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ub_server_stats {
    #[doc = " number of queries from clients received."]
    pub num_queries: ::std::os::raw::c_longlong,
    #[doc = " number of queries that have been dropped/ratelimited by ip."]
    pub num_queries_ip_ratelimited: ::std::os::raw::c_longlong,
    #[doc = " number of queries with a valid DNS Cookie."]
    pub num_queries_cookie_valid: ::std::os::raw::c_longlong,
    #[doc = " number of queries with only the client part of the DNS Cookie."]
    pub num_queries_cookie_client: ::std::os::raw::c_longlong,
    #[doc = " number of queries with invalid DNS Cookie."]
    pub num_queries_cookie_invalid: ::std::os::raw::c_longlong,
    #[doc = " number of queries that had a cache-miss."]
    pub num_queries_missed_cache: ::std::os::raw::c_longlong,
    #[doc = " number of prefetch queries - cachehits with prefetch"]
    pub num_queries_prefetch: ::std::os::raw::c_longlong,
    #[doc = " number of queries which are too late to process"]
    pub num_queries_timed_out: ::std::os::raw::c_longlong,
    #[doc = " the longest wait time in the queue"]
    pub max_query_time_us: ::std::os::raw::c_longlong,
    #[doc = " Sum of the querylistsize of the worker for\n every query that missed cache. To calculate average."]
    pub sum_query_list_size: ::std::os::raw::c_longlong,
    #[doc = " max value of query list size reached."]
    pub max_query_list_size: ::std::os::raw::c_longlong,
    #[doc = " Extended stats below (bool)"]
    pub extended: ::std::os::raw::c_int,
    #[doc = " qtype stats"]
    pub qtype: [::std::os::raw::c_longlong; 256usize],
    #[doc = " bigger qtype values not in array"]
    pub qtype_big: ::std::os::raw::c_longlong,
    #[doc = " qclass stats"]
    pub qclass: [::std::os::raw::c_longlong; 256usize],
    #[doc = " bigger qclass values not in array"]
    pub qclass_big: ::std::os::raw::c_longlong,
    #[doc = " query opcodes"]
    pub qopcode: [::std::os::raw::c_longlong; 16usize],
    #[doc = " number of queries over TCP"]
    pub qtcp: ::std::os::raw::c_longlong,
    #[doc = " number of outgoing queries over TCP"]
    pub qtcp_outgoing: ::std::os::raw::c_longlong,
    #[doc = " number of outgoing queries over UDP"]
    pub qudp_outgoing: ::std::os::raw::c_longlong,
    #[doc = " number of queries over (DNS over) TLS"]
    pub qtls: ::std::os::raw::c_longlong,
    #[doc = " number of queries over (DNS over) HTTPS"]
    pub qhttps: ::std::os::raw::c_longlong,
    #[doc = " number of queries over IPv6"]
    pub qipv6: ::std::os::raw::c_longlong,
    #[doc = " number of queries with QR bit"]
    pub qbit_QR: ::std::os::raw::c_longlong,
    #[doc = " number of queries with AA bit"]
    pub qbit_AA: ::std::os::raw::c_longlong,
    #[doc = " number of queries with TC bit"]
    pub qbit_TC: ::std::os::raw::c_longlong,
    #[doc = " number of queries with RD bit"]
    pub qbit_RD: ::std::os::raw::c_longlong,
    #[doc = " number of queries with RA bit"]
    pub qbit_RA: ::std::os::raw::c_longlong,
    #[doc = " number of queries with Z bit"]
    pub qbit_Z: ::std::os::raw::c_longlong,
    #[doc = " number of queries with AD bit"]
    pub qbit_AD: ::std::os::raw::c_longlong,
    #[doc = " number of queries with CD bit"]
    pub qbit_CD: ::std::os::raw::c_longlong,
    #[doc = " number of queries with EDNS OPT record"]
    pub qEDNS: ::std::os::raw::c_longlong,
    #[doc = " number of queries with EDNS with DO flag"]
    pub qEDNS_DO: ::std::os::raw::c_longlong,
    #[doc = " answer rcodes"]
    pub ans_rcode: [::std::os::raw::c_longlong; 16usize],
    #[doc = " answers with pseudo rcode 'nodata'"]
    pub ans_rcode_nodata: ::std::os::raw::c_longlong,
    #[doc = " answers that were secure (AD)"]
    pub ans_secure: ::std::os::raw::c_longlong,
    #[doc = " answers that were bogus (withheld as SERVFAIL)"]
    pub ans_bogus: ::std::os::raw::c_longlong,
    #[doc = " rrsets marked bogus by validator"]
    pub rrset_bogus: ::std::os::raw::c_longlong,
    #[doc = " number of queries that have been ratelimited by domain recursion."]
    pub queries_ratelimited: ::std::os::raw::c_longlong,
    #[doc = " unwanted traffic received on server-facing ports"]
    pub unwanted_replies: ::std::os::raw::c_longlong,
    #[doc = " unwanted traffic received on client-facing ports"]
    pub unwanted_queries: ::std::os::raw::c_longlong,
    #[doc = " usage of tcp accept list"]
    pub tcp_accept_usage: ::std::os::raw::c_longlong,
    #[doc = " expired answers served from cache"]
    pub ans_expired: ::std::os::raw::c_longlong,
    #[doc = " histogram data exported to array\n if the array is the same size, no data is lost, and\n if all histograms are same size (is so by default) then\n adding up works well."]
    pub hist: [::std::os::raw::c_longlong; 40usize],
    #[doc = " number of message cache entries"]
    pub msg_cache_count: ::std::os::raw::c_longlong,
    #[doc = " number of rrset cache entries"]
    pub rrset_cache_count: ::std::os::raw::c_longlong,
    #[doc = " number of infra cache entries"]
    pub infra_cache_count: ::std::os::raw::c_longlong,
    #[doc = " number of key cache entries"]
    pub key_cache_count: ::std::os::raw::c_longlong,
    #[doc = " maximum number of collisions in the msg cache"]
    pub msg_cache_max_collisions: ::std::os::raw::c_longlong,
    #[doc = " maximum number of collisions in the rrset cache"]
    pub rrset_cache_max_collisions: ::std::os::raw::c_longlong,
    #[doc = " number of queries that used dnscrypt"]
    pub num_query_dnscrypt_crypted: ::std::os::raw::c_longlong,
    #[doc = " number of queries that queried dnscrypt certificates"]
    pub num_query_dnscrypt_cert: ::std::os::raw::c_longlong,
    #[doc = " number of queries in clear text and not asking for the certificates"]
    pub num_query_dnscrypt_cleartext: ::std::os::raw::c_longlong,
    #[doc = " number of malformed encrypted queries"]
    pub num_query_dnscrypt_crypted_malformed: ::std::os::raw::c_longlong,
    #[doc = " number of queries which did not have a shared secret in cache"]
    pub num_query_dnscrypt_secret_missed_cache: ::std::os::raw::c_longlong,
    #[doc = " number of dnscrypt shared secret cache entries"]
    pub shared_secret_cache_count: ::std::os::raw::c_longlong,
    #[doc = " number of queries which are replays"]
    pub num_query_dnscrypt_replay: ::std::os::raw::c_longlong,
    #[doc = " number of dnscrypt nonces cache entries"]
    pub nonce_cache_count: ::std::os::raw::c_longlong,
    #[doc = " number of queries for unbound's auth_zones, upstream query"]
    pub num_query_authzone_up: ::std::os::raw::c_longlong,
    #[doc = " number of queries for unbound's auth_zones, downstream answers"]
    pub num_query_authzone_down: ::std::os::raw::c_longlong,
    #[doc = " number of times neg cache records were used to generate NOERROR\n responses."]
    pub num_neg_cache_noerror: ::std::os::raw::c_longlong,
    #[doc = " number of times neg cache records were used to generate NXDOMAIN\n responses."]
    pub num_neg_cache_nxdomain: ::std::os::raw::c_longlong,
    #[doc = " number of queries answered from edns-subnet specific data"]
    pub num_query_subnet: ::std::os::raw::c_longlong,
    #[doc = " number of queries answered from edns-subnet specific data, and\n the answer was from the edns-subnet cache."]
    pub num_query_subnet_cache: ::std::os::raw::c_longlong,
    #[doc = " number of queries served from cachedb"]
    pub num_query_cachedb: ::std::os::raw::c_longlong,
    #[doc = " number of bytes in the stream wait buffers"]
    pub mem_stream_wait: ::std::os::raw::c_longlong,
    #[doc = " number of bytes in the HTTP2 query buffers"]
    pub mem_http2_query_buffer: ::std::os::raw::c_longlong,
    #[doc = " number of bytes in the HTTP2 response buffers"]
    pub mem_http2_response_buffer: ::std::os::raw::c_longlong,
    #[doc = " number of TLS connection resume"]
    pub qtls_resume: ::std::os::raw::c_longlong,
    #[doc = " RPZ action stats"]
    pub rpz_action: [::std::os::raw::c_longlong; 10usize],
}
#[doc = " Statistics to send over the control pipe when asked\n This struct is made to be memcopied, sent in binary.\n shm mapped with (number+1) at num_threads+1, with first as total"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ub_stats_info {
    #[doc = " the thread stats"]
    pub svr: ub_server_stats,
    #[doc = " mesh stats: current number of states"]
    pub mesh_num_states: ::std::os::raw::c_longlong,
    #[doc = " mesh stats: current number of reply (user) states"]
    pub mesh_num_reply_states: ::std::os::raw::c_longlong,
    #[doc = " mesh stats: number of reply states overwritten with a new one"]
    pub mesh_jostled: ::std::os::raw::c_longlong,
    #[doc = " mesh stats: number of incoming queries dropped"]
    pub mesh_dropped: ::std::os::raw::c_longlong,
    #[doc = " mesh stats: replies sent"]
    pub mesh_replies_sent: ::std::os::raw::c_longlong,
    #[doc = " mesh stats: sum of waiting times for the replies"]
    pub mesh_replies_sum_wait_sec: ::std::os::raw::c_longlong,
    #[doc = " mesh stats: sum of waiting times for the replies"]
    pub mesh_replies_sum_wait_usec: ::std::os::raw::c_longlong,
    #[doc = " mesh stats: median of waiting times for replies (in sec)"]
    pub mesh_time_median: f64,
}
